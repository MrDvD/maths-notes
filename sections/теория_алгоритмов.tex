\section{Теория алгоритмов}

\subsection{Поиск с возвратом}

{\bold Поиск с возвратом} --- метод нахождения решений задачи полным перебором допустимых расстановок элементов конечного множества:

\begin{tabularcx}{0pt}{3pt}{r @{ } L}{\textwidth}
--- & в качестве {\ital частичного решения} используется пустое упо"=рядоченное множество $M$, которое расширяется до пол"=ного по одному элементу за операцию;\\
--- & если решение {\ital полное} или {\ital не удовлетворяет условию}, алгоритм приступает к другому частичному решению.
\end{tabularcx}

Пусть $T_1=\langle V_1,E_1\rangle$, $T_2=\langle V_2,E_2\rangle$ --- корневые деревья.

{\ital Кандидат} для $v\in V_1$ --- элемент множества
% ---
$$C_v:=\{w\mid w\in V_2,\ \text{depth}_v=\text{depth}_w\}\cup\{\lambda\}.$$
% ---
{\ital Возвратное дерево} для $T_1$ и $T_2$ --- такое дерево $T=\langle V,E\rangle$ с~мнимым корнем, что:
% ---
$$\begin{cases*}
&M\subseteq V_1\times W\text{ \ital\color{desc}(упорядочено, биективно)}\\
&{\begin{rcases*}
&W=[\text{root}_T,\dots,w]\backslash\{\text{root}_T\}\subseteq V_2\cup\{\lambda\}\subseteq V\\
&\text{children}_w=\emptyset\end{rcases*}}\text{ I}\\
&{\begin{rcases*}
&\forall\langle w_1,w_2\rangle\subseteq W\ \text{order}(w_1)\less\text{order}(w_2)\hspace*{23pt}\\
&w_1,w_2\neq\lambda\end{rcases*}}\text{ II}\\
&\forall\langle v_i,w_j\rangle\in M\ w_j\in C_{v_i}\hspace*{115pt}\bigr\}\text{\hspace*{6.3pt}III}
\end{cases*}$$
% ---
\begin{tabularcx}{0pt}{3pt}{r @{ --- } L}{.98\textwidth}
I & всякая простая цепь возвратного дерева от корня до~листа без корня соответствует {\ital уникальному} отображению $T_1$ в $T_2$;\\
II & индекс узлов одной простой цепи от корня до листа без корня {\ital строго возрастает};\\
III & всякий узел простой цепи от корня до листа без корня является {\ital кандидатом} для соответствующего узла $T_1$.
\end{tabularcx}

Итерация построения полного решения $M$ для условия $P$:
% ---
$$\begin{cases}
\forall c\in C_{W.\text{last}()}\ W:=W\cup\{c\}\\
T(M):=M\text{ --- частичное решение}\\
M\land P(M)\land T(M)\neq\emptyset\implies\text{расширить M}\\
M\land P(M)\land T(M)=\emptyset\implies\text{следующее M}
\end{cases}$$
% ---
{\ital Дерево ветвей и границ} для $T_1$ и $T_2$ --- такое возвратное дерево для $T_1$ и $T_2$, что $P:=P\land R$, где:
% ---
$$R(M_i)=\begin{cases}
\alpha_{\text{\tinyt min}}=\emptyset\implies\alpha_{\text{\tinyt min}}:=\text{max}\\
\alpha_\text{\tinyt min}\geq\gamma(M_i)\implies\text{True, }\alpha_\text{\tinyt min}:=\gamma(M_i)\\
\alpha_\text{\tinyt min}\less\gamma(M_i)\implies\text{False}\\
\end{cases}$$

\subsection{«Разделяй и властвуй»}

{\bold «Разделяй и властвуй»} --- метод рекурсивного нахождения решений задачи: 
% ---
\begin{tabularcx}{0pt}{3pt}{r @{ --- } L}{\textwidth}
& задача делится на меньшие, {\ital независимые} друг от друга подзадачи, пока они не будут сведены к {\ital тривиальным};\\
& решения тривиальных подзадач {\ital комбинируются} в еди"=ное к исходной задаче.
\end{tabularcx}

Пусть $T_1=\langle V_1,E_1\rangle$, $T_2=\langle V_2,E_2\rangle$ --- корневые деревья, $A_1=$ $T_{1W_1}$, $A_2=T_{2W_2}$, $B_1=T_1\backslash A_1$, $B_2=T_2\backslash A_2$ --- их поддеревья:
% ---
$$\begin{cases}
W_1=\{v_m\in V_1\mid\text{order}(v_m)\less\text{order}(v)\}\\
W_2=\{w_n\in V_2\mid\text{order}(w_p)\less\text{order}(w)\}\\
v:=\text{last}_{v_i},\ w:=\text{last}_{w_k}
\end{cases}$$
% ---
{\ital Дерево «разделяй и властвуй»} для $T_1$ и $T_2$ --- такое ордерево $T=\langle V,E\rangle$ с вершинами вида $v_iv_jw_kw_l$, что:
% ---
$$\begin{cases}
v_i,v_j\in V_1,\ w_k,w_l\in V_2\\
\text{root}_T=v_1v_{n_1}w_1w_{n_2}\ {\ital\color{desc} (T_1\to T_2)}\\
\end{cases}$$
% ---
Шаг рекурсивного построения решения $M$:
% ---
$$\begin{cases*}
&v_i=v_j,\ w_k=w_l\implies v_i\mapsto w_k\text{, комбинировать}\\
&v_i\neq v_j,\ w_k=w_l\implies A_1\to T_2\ (B_1\to\lambda)\\
&v_i=v_j,\ w_k\neq w_l\implies T_1\to A_2\ (\lambda\to B_2)\\
&v_i\neq v_j,\ w_k\neq w_l\implies\begin{sqcases*}
&A_1\to A_2\text{ или }A_1\to T_2\\
&B_1\to B_2\text{ или }T_1\to A_2
\end{sqcases*}\end{cases*}$$


\subsection{Динамика}

{\bold Динамическое программирование} --- метод рекурсив"=ного нахождения решений задачи:
% ---
\begin{tabularcx}{0pt}{3pt}{r @{ --- } L}{\textwidth}
& задача делится на меньшие, {\ital зависимые} друг от друга подзадачи, пока они не будут сведены к {\ital тривиальным};\\
& решения тривиальных подзадач {\ital комбинируются} в еди"=ное к исходной задаче.
\end{tabularcx}

{\bold Мемоизация} {\ital\color{desc} («сверху вниз»)} --- кеширование и повторное использование ранее подсчитанных результатов.

{\bold Табуляция} {\ital\color{desc} («снизу вверх»)} --- заполнение кеша на основе тривиальных подзадач.

Лучшее решение выбирается из матрицы лучших решений его подграфов {\ital\color{desc} (у них по рекурсии есть свои матрицы)}:
% ---
$$\begin{matrix}
\langle v_i,w_k\rangle & \langle v_i,w_kw_{k+1}\rangle & \cdots & \langle v_i,w_k\dots w_l\rangle\\
\langle v_iv_{i+1},w_k\rangle & \langle v_iv_{i+1},w_kw_{k+1}\rangle & \cdots & \langle v_iv_{i+1},w_k\dots w_l\rangle\\
\vdots & \vdots & \ddots & \vdots\\
\langle v_i\dots v_j,w_k\rangle & \langle v_i\dots v_j,w_kw_{k+1}\rangle & \cdots & \langle v_i\dots v_j,w_k\dots w_l\rangle
\end{matrix}$$
% ---
$$\begin{cases}
v\in V_1,\ w\in V_2\\
\text{depth}_v=\text{depth}_w\\
\{v_i,\dots,v_j\}=\text{children}_v\\
\{w_k,\dots,w_l\}=\text{children}_w\\
\langle v_i\dots v_j,w_k\dots w_l\rangle\sim\gamma_{\text{\tinyt min}}(G_1\to G_2)\\
G_1=T_{1W_i}\cup\dots\cup T_{1W_j}\\
G_2=T_{2W_k}\cup\dots\cup T_{2W_l}\\
\forall s\in\{i,\dots,j\}\ \text{root}_{T_{1Ws}}=v_s\\
\forall t\in\{k,\dots,l\}\ \text{root}_{T_{2Wt}}=w_t
\end{cases}$$
% ---
Алгоритм табуляции занимает $\mathcal{O}(n_1n_2)$ места, используя $\mathcal{O}(n_1n_2)$ времени.

% Проверить корректность записи с \land (дерево ветвей и границ)
% НАПИСАТЬ В ТЕОРИИ ПРО УПОРЯДОЧЕННОЕ СООТВЕТСТВИЕ

\subsection{Уравнение Беллмана}

Введём задачу на оптимизацию вида:

\begin{tabularcx}{0pt}{3pt}{>{\centering\arraybackslash}m{39mm}r @{ --- } L}{\textwidth}
\multirow{3}{*}{\vspace*{-6pt}$\displaystyle\optm{d\in\Delta}\{H(d)\}$} & $d$ & выбор;\\
& $\Delta$ & допустимое множество;\\
& $H$ & целевая функция одной переменной.
\end{tabularcx}

{\ital Оптимум} --- оптимальное значение целевой функции {\ital\color{desc} (выбор $d^*$ оптимизирует $H$)}:
% ---
$$H^*:=H(d^*)\quad\quad d^*:=\text{arg }\optm{d\in\Delta}\{H(d)\}$$
% ---
Пусть $H$ --- целевая функция нескольких переменных.

Оптимум такой задачи можно найти либо {\ital полным перебо"=ром}, либо {\ital последовательным принятием решений}:
% ---
$$\begin{aligned}
H^*&=\optm{\langle d_1,\dots,d_n\rangle\in\Delta}\{H(d_1,\dots,d_n)\}\\
&=\optm{d_1\in D_1}\{\optm{d_2\in D_2}\{\dots\{\optm{d_n\in D_n}\{h(d_1,\dots,d_n)\}\}\dots\}\}\\
&=\optm{d_1\in D_1}\{H(d_1,d^*_2(d_1),\dots,d^*_n(d_1))\}
\end{aligned}$$

\begin{tabularcx}{0pt}{3pt}{r @{ --- } L}{\textwidth}
$\Delta=D_1\times\dots\times D_n$ & пространство решений;\\
$D_n(d_1,\dots,d_{n-1})$ & множество решений, которое зависит от~предыдущих $\langle d_1,\dots, d_{n-1}\rangle$ решений;\\
$d^*_i(d_1,\dots,d_{i-1})$ & локальный выбор $d$, оптимизирующий $H$.
\end{tabularcx}

\subsection{Распределение ресурсов}

В задаче на {\ital оптимальное распределение ресурсов} требуется разделить ограниченное число ресурсов на множество их потребителей, у которых есть стоимость.

Общая формула:
% ---
$$f(k,m)=\min_{d\in\{0,\dots,m\}}\{C(k,d)+f(k+1,m-d)\}$$

\newpage
\subsection{Жадные алгоритмы}

Список жадных алгоритмов:
% ---
\begin{list*}
\item перевод числа из десятичной системы счисления в $m$-ичную:
\begin{list*}[2]
\item задача о размене монет.
\end{list*}
\item что-то...
\end{list*}

\newpage
\subsection{Бинарный поиск}

{\bold Бинарный поиск} на отрезке $[a;b]$ --- метод поиска корня монотонной функции $f\in\mathbb{C}[a;b]$. 

{\bold Правым} называется такой бинарный поиск, который ищет {\ital верхнюю границу} монотонной функции {\ital\color{desc}(максимальное $x$, при котором есть корни)}:
% ---
$$mid=\ceil{\frac{l+r}{2}}$$
% ---
{\bold Левым} называется такой бинарный поиск, который ищет {\ital нижнюю границу} монотонной функции {\ital\color{desc}(минимальное $x$, при~котором есть корни)}:
% ---
$$mid=\floor{\frac{l+r}{2}}$$
% ---
\begin{theorem}
{\bold Задача.} Один принтер печатает лист раз в $x$ мин., другой --- раз в $y$ мин. За сколько минут они напечатают $N$ листов? {\ital\color{desc}(задача имеет решение за константу)}
\end{theorem}

{\bold Идея.} Решим обратную задачу бинарным поиском по $j$:
% ---
\begin{list*}
\item сколько листов напечатают оба принтера за $j$ мин.?
\end{list*}
% ---
Значит, ищем такое минимальное $j$, что верно:
% ---
$$\floor{\frac{j}{x}}+\floor{\frac{j}{y}}\geq N$$
% ---
\begin{theorem}
{\bold Задача.} На прямой есть $N$ стойл. Максимизировать минимальное расcтояние между $K\less N$ коровами.
\end{theorem}

{\bold Идея.} Решим обратную задачу бинарным поиском по $j$:
% ---
\begin{list*}
\item расположить $K$ коров так, чтобы минимальное расстояние между ними было не больше $j$ 
\end{list*}
% ---
Коровы расположим {\ital жадно}: в самых левых свободных стойлах, расстояние между которыми {\ital не больше} $j$.

\begin{theorem}
{\bold Задача.} Дано $N$ отрезков различных длин. Получить разрезаниями $K$ равных отрезков максимальной длины.
\end{theorem}

{\bold Идея.} Решим обратную задачу бинарным поиском по $j$:
% ---
\begin{list*}
\item разрезать $N$ отрезков разных длин на $K$ отрезков длины $j$
\end{list*}
% ---
Значит, ищем такое максимальное $j$, что верно:
% ---
$$\sum_{i=1}^N\floor{\frac{a_i}{j}}\geq K$$
% ---
\begin{theorem}
{\bold Задача.} Есть $N$ дипломов $h\times w$. Минимизировать сторону квадратной стены, на которой они будут размещены в целых координатах без поворотов.
\end{theorem}

{\bold Идея.} Решим обратную задачу бинарным поиском по $j$:
% ---
\begin{list*}
\item Разместить $N$ дипломов на квадратной стене со стороной $j$
\end{list*}
% ---
Разместим дипломы {\ital жадно}: в самых верхних левых свободных координатах, иначе спустимся на уровень ниже.

\begin{theorem}
{\bold Задача.} Исследовательские модули с защитой толщины $d$ --- прямоугольники $(a+2d)\times (b+2d)$. Максимизировать $d$ для размещения модулей в поле $w\times h$.
\end{theorem}

{\bold Идея.} Решим обратную задачу бинарным поиском по $j$:
% ---
\begin{list*}
\item Разместить модули размеров $(a+2j)\times (b+2j)$ в поле $w\times h$.
\end{list*}
% ---
Разместим модули {\ital жадно}: в самых верхних левых свободных координатах, иначе спустимся на уровень ниже.

\begin{theorem}
{\bold Задача.} Два лесоруба срубают $A$ и $B$ деревьев в день, но отдыхают каждый $K$-ый и $M$-ый дни соответственно. За сколько дней они управятся с $X$ деревьями?
\end{theorem}

{\bold Идея.} Решим обратную задачу бинарным поиском по $j$:
% ---
\begin{list*}
\item сколько деревьев лесорубы срубят за $j$ дней?
\end{list*}
% ---
Значит, ищем такое минимальное $j$, что верно:
% ---
$$\begin{gathered}
(A+B)j-A\floor{\frac{j}{K}}-B\floor{\frac{j}{M}}\geq X\iff\\
A\left(j-\floor{\frac{j}{K}}\right)+B\left(j-\floor{\frac{j}{M}}\right)\geq X
\end{gathered}$$
% ---
\begin{theorem}
{\bold Задача.} В классе учатся $N$ человек различного роста. Составить $R$ бригад по $C$ человек так, чтобы максимальная разница в росте одной бригады была минимальна. 
\end{theorem}

{\bold Идея.} Решим обратную задачу бинарным поиском по $j$:
% ---
\begin{list*}
\item составить $R$ бригад по $C$ человек с максимальной разницей в росте $j$. 
\end{list*}
% ---
Выберем бригады {\ital жадно}: отсортируем школьников по росту, выберем самую левую бригаду, удовлетворяющую условиям.

Продолжим цикл, пока не {\ital наберётся} нужное число бригад, либо школьники не {\ital закончатся}.

\begin{theorem}
{\bold Задача.} Бетси может делать печенье за $t_C$ ед. времени и~булочку за $t_M$. Заказ выполняется не дольше $C_i$. Бетси может улучшить свою печь за монету, чтобы она производила печенье или булочку на единицу быстрее {\ital\color{desc}(за положительное время)}. Минимизировать количество монет, чтобы выполнить все заказы.
\end{theorem}

{\bold Идея.} Пусть в оптимальном случае было затрачено $w$ монет, и печь производит печенье за $x$ ед. времени, а булочку --- за $y$.

По условию задачи составим систему:
% ---
$$\begin{cases*}
&1\leq x\leq t_C\\
&1\leq y\leq t_M\\
&x+y=t_C+t_M-w\\
&Ax+By\leq C
\end{cases*}$$
% ---
Из двух последних выражений следует:
% ---
$$(A-B)x\leq C-B(t_C+t_M-w)$$
% ---
При делении неравенства на $A-B$ с учётом знака получим одну границу $x$ {\ital\color{desc}(случай $A=B$ обрабатывается отдельно)}.

Из первых трёх выражений найдём другую границу для $x$:
% ---
$$\begin{cases*}
&1\leq x\leq t_C\\
&t_C-w\leq x\leq t_C+t_M-w-1
\end{cases*}$$
% ---
Задача решается бинарным поиском по $w$: если множество допустимых $x$ непустое, то $w$ подходит.

\begin{theorem}
{\bold Задача.} Найти медиану таблица умножения $N\times N$.
\end{theorem}

{\bold Идея.} Пусть $f(x)$ --- количество натуральных чисел, не~больших $x$.

По определению медианы $m$:
% ---
$$f(m)\geq\floor{\frac{n^2}{2}}$$
% ---
Количество элементов строки, кратных её номеру $i$ и не больших медианы $m$, равно:
% ---
$$j_\text{max}=\floor{\frac{m}{i}}$$
% ---
Задача решается бинарным поиском по $m$.

\subsection{Тернарный поиск}

{\bold Бинпоиск по производной?}

{\bold Унимодальной} на отрезке $[a;b]$ называется такая функция $f\in\mathbb{C}[a;b]$, которая имеет на нём {\ital один экстремум}.

{\bold Тернарный поиск} --- метод поиска экстремума унимодальной функции.

\begin{theorem}
{\bold Теорема.} Вдоль прямой дороги расположились друзья в некоторых координатах. Каждый из них может идти с максимальной скоростью $v_i$. Найти минимальное время встречи всех друзей в одной точке с точностью до $10^{-6}$.
\end{theorem}

{\bold Идея.} Переформулируем задачу:
% ---
\begin{list*}
\item найти координату $x_0$ места встречи, до которой все друзья дойдут за минимальное время
\end{list*}

Тернарным поиском по $x_0$ с $\varepsilon\less 10^{-6}$ найдём минимальное время:
% ---
$$v_i=\frac{\abs{x_0-x_i}}{\tau_i}\implies\tau_i=\frac{\abs{x_0-x_i}}{v_i}\implies\tau=\max\{\tau_i\mid\forall i\}$$
