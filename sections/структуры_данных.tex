\section{Структуры данных}

\subsection{Стек}

\begin{theorem}
{\bold Задача.} Вычислить область самого большого прямоугольника в гистограмме, который находится на общей базовой линии.
\end{theorem}

{\bold Идея.} Введём два фиктивных столбца: один отрицательной высоты {\ital (в начало)}, другой --- нулевой {\ital (в конец)}.

Пока гистограмма {\ital строго возрастает}, добавлять столбцы в~стек.

В противном случае, если высота $i$-го столбца $\leq$ вершины стека:
% ---
\begin{list*}[][\#]
\item Убирать из стека столбцы, пока гистограмма не станет {\ital строго возрастающей}.
\item Считать площадь прямоугольника от $i-1$ до последнего убранного столбца $x$:
% ---
$$S=h_x(i-x)$$
\item По достижении строго возрастающей последовательности добавить в стек столбец с параметрами:
% ---
\begin{list*}
\item $h$ текущего столбца
\item $x$ последнего удалённого столбца
\end{list*}
\end{list*}

\subsection{Ближайшее меньшее}

\begin{theorem}
{\bold Задача.} Дан массив чисел. Для каждого элемента $x$ найти такое ближайшее число $y$ слева, что $x\less y$.
\end{theorem}

{\bold Идея.} Введём вспомогательный массив и {\ital стек}, в который постепенно будем помещать все элементы массива, большие вершины.

Если элемент массива $a_i$ меньше вершины стека $a_j$, то для элемента $i$ ближайшим большим числом будет являться вершина стека.

За счёт вспомогательного массива после линейной обработки исходного массива можно добиться {\ital константного} времени.

\subsection{Префиксная сумма}

{\bold Префиксная сумма} --- это...

\begin{theorem}
{\bold Задача.} Дан массив целых чисел. Найти подотрезок с~максимальной суммой.
\end{theorem}

{\bold Идея.} Составим массив префиксных сумм $\pi$.

Начнём перебирать правую границу $r$ искомого отрезка, так что остаётся найти величину:
% ---
$$\min\{\pi_r-\pi_i\mid i\in[0;r)\}$$
% ---
Заметим, что оптимальный вариант левой границы искомого отрезка --- {\ital глобальный минимум} на интервале $[0;r)$.

Таким образом, задача решается за {\ital линейное} время.

\subsection{Стек рекордов}

{\bold Стек рекордов} --- монотонная подпоследовательность массива, для любых элементов которой верно:
% ---
$$i\leq j,\ a_i\less a_j\quad\text{или}\quad i\leq j,\ a_i\greater a_j$$
% ---
\begin{theorem}
{\bold Задача.} Дан массив чисел. Найти минимумы для всех отрезков длины $K$.
\end{theorem}
% ---
{\bold Идея.} Введём стек минимумов, в который будем добавлять элементы по правилу:
% ---
\begin{list*}[][\#]
\item Элемент $\greater$ вершины $\implies$ добавить в стек
\item Элемент $\leq$ вершины $\implies$ убирать верхние элементы до~достижения возрастающей последовательности
\end{list*}
% ---
Если последний элемент стека не входит в $K$-отрезок, то~убрать его {\ital\color{desc}(для этого лучше подходит очередь)}.

\newpage
\subsection{Дерево отрезков}

{\bold Дерево отрезков} --- бинарное дерево для массива $arr$, на~котором можно реализовать массовые ассоциативные операции $f$ за {\ital логарифмическое время}:
% ---
\begin{list*}[][\#]
\item Листья --- элементы массива $arr$
\item Родитель содержит {\ital результат операции} от своих детей
\item Корень содержит {\ital результат операции} от $arr$ на $[0;n)$
\end{list*}

Два вида:
% ---
\begin{list*}
\item ДО сверху --- рекурсивный вариант
\item ДО снизу --- итеративный вариант
\end{list*}

\subsection{Одиночное обновление}

{\bold Построение.} По принципу {\ital «разделяй и властвуй»}:
% ---
\begin{code}{python}
def build(v, l, r):
  if l == r:
    verts[v].val = arr[l]
  else:
    mid = (l + r) // 2
    build(2 * v, l, mid)
    build(2 * v + 1, mid + 1, r)
    verts[v].val = f(verts[2 * v].val, \
                     verts[2 * v + 1].val)
\end{code}

{\bold Обновление.} По принципу {\ital «разделяй и властвуй»}:
% ---
\begin{code}{python}
def update(v, l, r, idx, val):
  if l == r:
    verts[v].val = val
  else:
    mid = (l + r) // 2
    if idx <= mid:
      update(2 * v, l, mid, idx, val)
    else:
      update(2 * v + 1, mid + 1, r, idx, val)
    verts[v].val = f(verts[2 * v].val, \
                     verts[2 * v + 1].val)
\end{code}

{\bold Запрос.} По принципу {\ital «разделяй и властвуй»}:
% ---
\begin{code}{python}
def get(v, l, r, L, R):
  if L > R:
    return # neutral element
  if l == L and r == R:
    return verts[v].val
  mid = (l + r) // 2
  return f(get(2 * v, l, mid, L, min(R, mid)), \
           get(2 * v + 1, mid + 1, r, \
                                 max(L, mid+1), R))
\end{code}

\subsection{Массовое обновление}

{\bold Обновление.} По принципу {\ital «разделяй и властвуй»} с~применением {\ital отложенных операций}:
% ---
\begin{code}{python}
def update(v, l, r, L, R, push):
  if L > R:
    return
  if l == L and r == R:
    verts[v].val = push
  else:
    mid = (l + r) // 2
    update(2 * v, l, mid, L, min(R, mid), push)
    update(2 * v + 1, \
           mid + 1, r, max(L, mid + 1), R, push)
\end{code}

{\bold Запрос.} По принципу {\ital «разделяй и властвуй»} --- это для одного элемента, а мне нужна сумма на отрезке!!!!!!!!:
% ---
\begin{code}{python}
def get(v, l, r, idx):
  if l == r:
    return verts[v].val
  mid = (l + r) // 2
  if idx <= mid:
    return verts[v].val + get(2 * v, l, mid, idx)
  else:
    return verts[v].val + get(2 * v + 1, \
                              mid + 1, r, idx)
\end{code}
